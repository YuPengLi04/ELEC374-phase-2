`timescale 1ns / 1ns
module Load_tb;

  reg Zout, Rout, HIout, LOout, Zhighout, Zlowout, 
      PCout, MDRout, InPortout, Cout;    
  reg MARin, Zin, PCin, MDRin, IRin, Yin;
  reg Gra, Grb, Grc, Rin;
  reg Read, IncPC, HIin, LOin, ZhighIn, ZlowIn, BAout, IRout;
  reg clock, clear;
  reg R0out, R1out, R2out, R3out, R4out, R5out, R6out, R7out, R8out, R9out, 
    R10out, R11out, R12out, R13out, R14out, R15out;

  // State encoding
  parameter Default = 4'b0000, T0 = 4'b0001, T1a = 4'b0010, T1b = 4'b0011,
            T2 = 4'b0100, T3 = 4'b0101, T4 = 4'b0110, T5 = 4'b0111, T6 = 4'b1000, T7 = 4'b1001;
  reg [3:0] Present_state = Default;

  // Instantiate DataPath module
  DataPath DUT (
    clock, clear, Gra, Grb, Grc,
    Zout, R0out, Rout, HIout, LOout, Zhighout, Zlowout, 
    PCout, MDRout, InPortout, Cout,    
    Zin, Yin, Rin, PCin, IRin, HIin, LOin, MARin, MDRin, Read, ZhighIn, ZlowIn, BAout
  );

  // Clock generation
  initial begin
    clock = 0;
    clear = 0;
    forever #10 clock = ~clock;
  end

  // State transition logic
  always @(posedge clock) begin
    if (clear)
      Present_state <= Default;
    else begin
      case (Present_state)
        Default: Present_state <= T0;
        T0: Present_state <= T1a;
        T1a: Present_state <= T1b;
        T1b: Present_state <= T2;
        T2: Present_state <= T3;
        T3: Present_state <= T4;
        T4: Present_state <= T5;
		  T5: Present_state <= T6;
        T6: Present_state <= T7;
       
      endcase
    end
  end
  
  initial begin
    // Initialize all R#out signals to 0
    R0out = 0; R1out = 0; R2out = 0; R3out = 0;
    R4out = 0; R5out = 0; R6out = 0; R7out = 0;
    R8out = 0; R9out = 0; R10out = 0; R11out = 0;
    R12out = 0; R13out = 0; R14out = 0; R15out = 0;
    
    HIout = 0; LOout = 0; Zhighout = 0; Zlowout = 0;
    PCout = 0; MDRout = 0; InPortout = 0; Cout = 0;

	end

  always @(Present_state) begin
    case(Present_state)
      Default: begin
		
		
			R0out <= 0; R1out <= 0; R2out <= 0; R3out <= 0; R4out <= 0;R5out <= 0; R6out <= 0; R7out <= 0; R8out <= 0; R9out <= 0; 
			R10out <= 0; R11out <= 0; R12out <= 0; R13out <= 0; R14out <= 0; R15out <= 0;
			HIout <= 0; LOout<= 0; Zhighout<= 0;
         Zlowout<= 0; PCout<= 0; MDRout<= 0; InPortout<= 0;
        
        PCout <= 0; Zlowout <= 0; MDRout <= 0; Zout <= 0;
        Rout <= 0; HIout <= 0; LOout <= 0; Zhighout <= 0; InPortout <= 0; Cout <= 0;
        MARin <= 0; PCin <= 0; MDRin <= 0; IRin <= 0; Yin <= 0; Zin <= 0;
        Gra <= 0; Grb <= 0; Grc <= 0; Rin <= 0; HIin <= 0; LOin <= 0;
        ZhighIn <= 0; ZlowIn <= 0; BAout <= 0;
        Read <= 0; IncPC <= 0;
        force DUT.BusMuxOut = 32'h00001000; 
//		  force DUT.bus.R0in = 32'h00000000;
//		  force DUT.bus.R1in = 32'h00000000;
//		  force DUT.bus.R2in = 32'h00000000;
//		  force DUT.bus.R3in = 32'h00000000;
//		  force DUT.bus.R4in = 32'h00000000;
//		  force DUT.bus.R5in = 32'h00000000;
//		  force DUT.bus.R6in = 32'h00000000;
//		  force DUT.bus.R7in = 32'h00000000;
//		  force DUT.bus.R8in = 32'h00000000;
//		  force DUT.bus.R9in = 32'h00000000;
//		  force DUT.bus.R10in = 32'h00000000;
//		  force DUT.bus.R11in = 32'h00000000;
//		  force DUT.bus.R12in = 32'h00000000;
//		  force DUT.bus.R13in = 32'h00000000;
//		  force DUT.bus.R14in = 32'h00000000;
//		  force DUT.bus.R15in = 32'h00000000;

      end

      // Load instruction address into MAR
      T0: begin
        PCout <= 1; MARin <= 1; IncPC<=1; ZlowIn<=1;
		  release DUT.BusMuxOut;
      end

      // Read instruction into MDR
      T1a: begin
        PCout <= 0; MARin <= 0; IncPC<=0; ZlowIn<=0;
        Read <= 1; Zlowout <= 1; PCin <= 1;
      end 

      T1b: begin
        MDRin <= 1;
      end

      // Move instruction from MDR to IR
      T2: begin
        MDRin <= 0; Read <= 0; Zlowout <= 0; PCin <= 0;
        MDRout <= 1; IRin <= 1;
      end

      // Extract memory location (0x54) from IR and store in MAR
      T3: begin
        MDRout <= 0; IRin <= 0;
		  
        BAout <= 1; Grb <= 1; Yin <= 1;
      end

      // Read memory at address 0x54 and store in MDR
      T4: begin
        BAout <= 0; Grb <= 0; Yin <= 0;
		  
        Cout <= 1; Zin <= 1;
      end

      // Move value from MDR to R4
      T5: begin
        Cout <= 0; Zin <= 0;
        MARin <= 1;  Zlowout <= 0;
      end
		
		T6: begin
        MARin <= 0;  Zlowout <= 0;
        Read <= 1; MDRin <= 1;
      end
		
		T7: begin
        Read <= 0; MDRin <= 0;
        MDRout <= 1; Gra<= 1; Rin <= 1;
      end
    endcase
  end

endmodule
